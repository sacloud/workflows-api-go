// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// CancelExecution invokes cancelExecution operation.
	//
	// ワークフローの実行をキャンセルする.
	//
	// POST /workflows/{id}/executions/{executionId}/cancel
	CancelExecution(ctx context.Context, params CancelExecutionParams) (CancelExecutionRes, error)
	// CreateExecution invokes createExecution operation.
	//
	// ワークフローを実行する.
	//
	// POST /workflows/{id}/executions
	CreateExecution(ctx context.Context, request OptCreateExecutionReq, params CreateExecutionParams) (CreateExecutionRes, error)
	// CreateSubscription invokes createSubscription operation.
	//
	// ワークフローの課金プランの設定をする.
	//
	// POST /subscriptions
	CreateSubscription(ctx context.Context, request *CreateSubscriptionReq) (CreateSubscriptionRes, error)
	// CreateWorkflow invokes createWorkflow operation.
	//
	// ワークフローを作成する.
	//
	// POST /workflows
	CreateWorkflow(ctx context.Context, request *CreateWorkflowReq) (CreateWorkflowRes, error)
	// CreateWorkflowRevision invokes createWorkflowRevision operation.
	//
	// ワークフローのリビジョンを追加する.
	//
	// POST /workflows/{id}/revisions
	CreateWorkflowRevision(ctx context.Context, request *CreateWorkflowRevisionReq, params CreateWorkflowRevisionParams) (CreateWorkflowRevisionRes, error)
	// DeleteExecution invokes deleteExecution operation.
	//
	// ワークフローの実行を削除する.
	//
	// DELETE /workflows/{id}/executions/{executionId}
	DeleteExecution(ctx context.Context, params DeleteExecutionParams) (DeleteExecutionRes, error)
	// DeleteSubscription invokes deleteSubscription operation.
	//
	// ワークフローの課金プランの削除をする.
	//
	// DELETE /subscriptions
	DeleteSubscription(ctx context.Context) (DeleteSubscriptionRes, error)
	// DeleteWorkflow invokes deleteWorkflow operation.
	//
	// ワークフローを削除する.
	//
	// DELETE /workflows/{id}
	DeleteWorkflow(ctx context.Context, params DeleteWorkflowParams) (DeleteWorkflowRes, error)
	// DeleteWorkflowRevisionAlias invokes deleteWorkflowRevisionAlias operation.
	//
	// ワークフローのリビジョンエイリアスを削除する.
	//
	// DELETE /workflows/{id}/revisions/{revisionId}/revision_alias
	DeleteWorkflowRevisionAlias(ctx context.Context, params DeleteWorkflowRevisionAliasParams) (DeleteWorkflowRevisionAliasRes, error)
	// GetExecution invokes getExecution operation.
	//
	// ワークフローの実行を取得する.
	//
	// GET /workflows/{id}/executions/{executionId}
	GetExecution(ctx context.Context, params GetExecutionParams) (GetExecutionRes, error)
	// GetSubscription invokes getSubscription operation.
	//
	// ワークフローの課金プランの取得をする.
	//
	// GET /subscriptions
	GetSubscription(ctx context.Context) (GetSubscriptionRes, error)
	// GetWorkflow invokes getWorkflow operation.
	//
	// ワークフローを取得する.
	//
	// GET /workflows/{id}
	GetWorkflow(ctx context.Context, params GetWorkflowParams) (GetWorkflowRes, error)
	// GetWorkflowRevisions invokes getWorkflowRevisions operation.
	//
	// ワークフローのリビジョンを取得する.
	//
	// GET /workflows/{id}/revisions/{revisionId}
	GetWorkflowRevisions(ctx context.Context, params GetWorkflowRevisionsParams) (GetWorkflowRevisionsRes, error)
	// ListExecution invokes listExecution operation.
	//
	// ワークフローの実行の一覧を取得する.
	//
	// GET /workflows/{id}/executions
	ListExecution(ctx context.Context, params ListExecutionParams) (ListExecutionRes, error)
	// ListExecutionHistory invokes listExecutionHistory operation.
	//
	// ワークフローの実行履歴を取得する.
	//
	// GET /workflows/{id}/executions/{executionId}/exec_history
	ListExecutionHistory(ctx context.Context, params ListExecutionHistoryParams) (ListExecutionHistoryRes, error)
	// ListPlans invokes listPlans operation.
	//
	// 現在契約可能な Workflows の料金プランの一覧を取得します。.
	//
	// GET /plans
	ListPlans(ctx context.Context) (ListPlansRes, error)
	// ListWorkflow invokes listWorkflow operation.
	//
	// ワークフローの一覧を取得する.
	//
	// GET /workflows
	ListWorkflow(ctx context.Context, params ListWorkflowParams) (ListWorkflowRes, error)
	// ListWorkflowRevisions invokes listWorkflowRevisions operation.
	//
	// ワークフローのリビジョンの一覧を取得する.
	//
	// GET /workflows/{id}/revisions
	ListWorkflowRevisions(ctx context.Context, params ListWorkflowRevisionsParams) (ListWorkflowRevisionsRes, error)
	// ListWorkflowSuggest invokes listWorkflowSuggest operation.
	//
	// ワークフローのサジェストを取得する.
	//
	// GET /workflows/suggest
	ListWorkflowSuggest(ctx context.Context, params ListWorkflowSuggestParams) (ListWorkflowSuggestRes, error)
	// UpdateWorkflow invokes updateWorkflow operation.
	//
	// ワークフローを更新する.
	//
	// PATCH /workflows/{id}
	UpdateWorkflow(ctx context.Context, request *UpdateWorkflowReq, params UpdateWorkflowParams) (UpdateWorkflowRes, error)
	// UpdateWorkflowRevisionAlias invokes updateWorkflowRevisionAlias operation.
	//
	// ワークフローのリビジョンエイリアスを更新する.
	//
	// PUT /workflows/{id}/revisions/{revisionId}/revision_alias
	UpdateWorkflowRevisionAlias(ctx context.Context, request *UpdateWorkflowRevisionAliasReq, params UpdateWorkflowRevisionAliasParams) (UpdateWorkflowRevisionAliasRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// CancelExecution invokes cancelExecution operation.
//
// ワークフローの実行をキャンセルする.
//
// POST /workflows/{id}/executions/{executionId}/cancel
func (c *Client) CancelExecution(ctx context.Context, params CancelExecutionParams) (CancelExecutionRes, error) {
	res, err := c.sendCancelExecution(ctx, params)
	return res, err
}

func (c *Client) sendCancelExecution(ctx context.Context, params CancelExecutionParams) (res CancelExecutionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/executions/"
	{
		// Encode "executionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "executionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExecutionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/cancel"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, CancelExecutionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCancelExecutionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateExecution invokes createExecution operation.
//
// ワークフローを実行する.
//
// POST /workflows/{id}/executions
func (c *Client) CreateExecution(ctx context.Context, request OptCreateExecutionReq, params CreateExecutionParams) (CreateExecutionRes, error) {
	res, err := c.sendCreateExecution(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateExecution(ctx context.Context, request OptCreateExecutionReq, params CreateExecutionParams) (res CreateExecutionRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/executions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateExecutionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, CreateExecutionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateExecutionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSubscription invokes createSubscription operation.
//
// ワークフローの課金プランの設定をする.
//
// POST /subscriptions
func (c *Client) CreateSubscription(ctx context.Context, request *CreateSubscriptionReq) (CreateSubscriptionRes, error) {
	res, err := c.sendCreateSubscription(ctx, request)
	return res, err
}

func (c *Client) sendCreateSubscription(ctx context.Context, request *CreateSubscriptionReq) (res CreateSubscriptionRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateSubscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, CreateSubscriptionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateWorkflow invokes createWorkflow operation.
//
// ワークフローを作成する.
//
// POST /workflows
func (c *Client) CreateWorkflow(ctx context.Context, request *CreateWorkflowReq) (CreateWorkflowRes, error) {
	res, err := c.sendCreateWorkflow(ctx, request)
	return res, err
}

func (c *Client) sendCreateWorkflow(ctx context.Context, request *CreateWorkflowReq) (res CreateWorkflowRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/workflows"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateWorkflowRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, CreateWorkflowOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateWorkflowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateWorkflowRevision invokes createWorkflowRevision operation.
//
// ワークフローのリビジョンを追加する.
//
// POST /workflows/{id}/revisions
func (c *Client) CreateWorkflowRevision(ctx context.Context, request *CreateWorkflowRevisionReq, params CreateWorkflowRevisionParams) (CreateWorkflowRevisionRes, error) {
	res, err := c.sendCreateWorkflowRevision(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateWorkflowRevision(ctx context.Context, request *CreateWorkflowRevisionReq, params CreateWorkflowRevisionParams) (res CreateWorkflowRevisionRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/revisions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateWorkflowRevisionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, CreateWorkflowRevisionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateWorkflowRevisionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteExecution invokes deleteExecution operation.
//
// ワークフローの実行を削除する.
//
// DELETE /workflows/{id}/executions/{executionId}
func (c *Client) DeleteExecution(ctx context.Context, params DeleteExecutionParams) (DeleteExecutionRes, error) {
	res, err := c.sendDeleteExecution(ctx, params)
	return res, err
}

func (c *Client) sendDeleteExecution(ctx context.Context, params DeleteExecutionParams) (res DeleteExecutionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/executions/"
	{
		// Encode "executionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "executionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExecutionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, DeleteExecutionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteExecutionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSubscription invokes deleteSubscription operation.
//
// ワークフローの課金プランの削除をする.
//
// DELETE /subscriptions
func (c *Client) DeleteSubscription(ctx context.Context) (DeleteSubscriptionRes, error) {
	res, err := c.sendDeleteSubscription(ctx)
	return res, err
}

func (c *Client) sendDeleteSubscription(ctx context.Context) (res DeleteSubscriptionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, DeleteSubscriptionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteWorkflow invokes deleteWorkflow operation.
//
// ワークフローを削除する.
//
// DELETE /workflows/{id}
func (c *Client) DeleteWorkflow(ctx context.Context, params DeleteWorkflowParams) (DeleteWorkflowRes, error) {
	res, err := c.sendDeleteWorkflow(ctx, params)
	return res, err
}

func (c *Client) sendDeleteWorkflow(ctx context.Context, params DeleteWorkflowParams) (res DeleteWorkflowRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, DeleteWorkflowOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteWorkflowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteWorkflowRevisionAlias invokes deleteWorkflowRevisionAlias operation.
//
// ワークフローのリビジョンエイリアスを削除する.
//
// DELETE /workflows/{id}/revisions/{revisionId}/revision_alias
func (c *Client) DeleteWorkflowRevisionAlias(ctx context.Context, params DeleteWorkflowRevisionAliasParams) (DeleteWorkflowRevisionAliasRes, error) {
	res, err := c.sendDeleteWorkflowRevisionAlias(ctx, params)
	return res, err
}

func (c *Client) sendDeleteWorkflowRevisionAlias(ctx context.Context, params DeleteWorkflowRevisionAliasParams) (res DeleteWorkflowRevisionAliasRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/revisions/"
	{
		// Encode "revisionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "revisionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RevisionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/revision_alias"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, DeleteWorkflowRevisionAliasOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteWorkflowRevisionAliasResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetExecution invokes getExecution operation.
//
// ワークフローの実行を取得する.
//
// GET /workflows/{id}/executions/{executionId}
func (c *Client) GetExecution(ctx context.Context, params GetExecutionParams) (GetExecutionRes, error) {
	res, err := c.sendGetExecution(ctx, params)
	return res, err
}

func (c *Client) sendGetExecution(ctx context.Context, params GetExecutionParams) (res GetExecutionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/executions/"
	{
		// Encode "executionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "executionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExecutionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, GetExecutionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetExecutionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSubscription invokes getSubscription operation.
//
// ワークフローの課金プランの取得をする.
//
// GET /subscriptions
func (c *Client) GetSubscription(ctx context.Context) (GetSubscriptionRes, error) {
	res, err := c.sendGetSubscription(ctx)
	return res, err
}

func (c *Client) sendGetSubscription(ctx context.Context) (res GetSubscriptionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, GetSubscriptionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkflow invokes getWorkflow operation.
//
// ワークフローを取得する.
//
// GET /workflows/{id}
func (c *Client) GetWorkflow(ctx context.Context, params GetWorkflowParams) (GetWorkflowRes, error) {
	res, err := c.sendGetWorkflow(ctx, params)
	return res, err
}

func (c *Client) sendGetWorkflow(ctx context.Context, params GetWorkflowParams) (res GetWorkflowRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, GetWorkflowOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWorkflowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkflowRevisions invokes getWorkflowRevisions operation.
//
// ワークフローのリビジョンを取得する.
//
// GET /workflows/{id}/revisions/{revisionId}
func (c *Client) GetWorkflowRevisions(ctx context.Context, params GetWorkflowRevisionsParams) (GetWorkflowRevisionsRes, error) {
	res, err := c.sendGetWorkflowRevisions(ctx, params)
	return res, err
}

func (c *Client) sendGetWorkflowRevisions(ctx context.Context, params GetWorkflowRevisionsParams) (res GetWorkflowRevisionsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/revisions/"
	{
		// Encode "revisionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "revisionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RevisionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, GetWorkflowRevisionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWorkflowRevisionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListExecution invokes listExecution operation.
//
// ワークフローの実行の一覧を取得する.
//
// GET /workflows/{id}/executions
func (c *Client) ListExecution(ctx context.Context, params ListExecutionParams) (ListExecutionRes, error) {
	res, err := c.sendListExecution(ctx, params)
	return res, err
}

func (c *Client) sendListExecution(ctx context.Context, params ListExecutionParams) (res ListExecutionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/executions"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "Page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "PageLimit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "PageLimit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageLimit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "Order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, ListExecutionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListExecutionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListExecutionHistory invokes listExecutionHistory operation.
//
// ワークフローの実行履歴を取得する.
//
// GET /workflows/{id}/executions/{executionId}/exec_history
func (c *Client) ListExecutionHistory(ctx context.Context, params ListExecutionHistoryParams) (ListExecutionHistoryRes, error) {
	res, err := c.sendListExecutionHistory(ctx, params)
	return res, err
}

func (c *Client) sendListExecutionHistory(ctx context.Context, params ListExecutionHistoryParams) (res ListExecutionHistoryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/executions/"
	{
		// Encode "executionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "executionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ExecutionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/exec_history"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "Page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "PageLimit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "PageLimit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageLimit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "SortOrder" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "SortOrder",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortOrder.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, ListExecutionHistoryOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListExecutionHistoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPlans invokes listPlans operation.
//
// 現在契約可能な Workflows の料金プランの一覧を取得します。.
//
// GET /plans
func (c *Client) ListPlans(ctx context.Context) (ListPlansRes, error) {
	res, err := c.sendListPlans(ctx)
	return res, err
}

func (c *Client) sendListPlans(ctx context.Context) (res ListPlansRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/plans"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, ListPlansOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListPlansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListWorkflow invokes listWorkflow operation.
//
// ワークフローの一覧を取得する.
//
// GET /workflows
func (c *Client) ListWorkflow(ctx context.Context, params ListWorkflowParams) (ListWorkflowRes, error) {
	res, err := c.sendListWorkflow(ctx, params)
	return res, err
}

func (c *Client) sendListWorkflow(ctx context.Context, params ListWorkflowParams) (res ListWorkflowRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/workflows"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "Page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "PageLimit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "PageLimit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageLimit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "SortBy" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "SortBy",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "Order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "Published" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Published",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Published.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "Name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "NameMatchType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "NameMatchType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NameMatchType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, ListWorkflowOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListWorkflowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListWorkflowRevisions invokes listWorkflowRevisions operation.
//
// ワークフローのリビジョンの一覧を取得する.
//
// GET /workflows/{id}/revisions
func (c *Client) ListWorkflowRevisions(ctx context.Context, params ListWorkflowRevisionsParams) (ListWorkflowRevisionsRes, error) {
	res, err := c.sendListWorkflowRevisions(ctx, params)
	return res, err
}

func (c *Client) sendListWorkflowRevisions(ctx context.Context, params ListWorkflowRevisionsParams) (res ListWorkflowRevisionsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/revisions"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "Page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "PageLimit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "PageLimit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageLimit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "SortBy" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "SortBy",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "Order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "Published" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Published",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Published.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, ListWorkflowRevisionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListWorkflowRevisionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListWorkflowSuggest invokes listWorkflowSuggest operation.
//
// ワークフローのサジェストを取得する.
//
// GET /workflows/suggest
func (c *Client) ListWorkflowSuggest(ctx context.Context, params ListWorkflowSuggestParams) (ListWorkflowSuggestRes, error) {
	res, err := c.sendListWorkflowSuggest(ctx, params)
	return res, err
}

func (c *Client) sendListWorkflowSuggest(ctx context.Context, params ListWorkflowSuggestParams) (res ListWorkflowSuggestRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/workflows/suggest"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "Name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "Page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "PageLimit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "PageLimit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageLimit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "SortBy" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "SortBy",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "Order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, ListWorkflowSuggestOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListWorkflowSuggestResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateWorkflow invokes updateWorkflow operation.
//
// ワークフローを更新する.
//
// PATCH /workflows/{id}
func (c *Client) UpdateWorkflow(ctx context.Context, request *UpdateWorkflowReq, params UpdateWorkflowParams) (UpdateWorkflowRes, error) {
	res, err := c.sendUpdateWorkflow(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateWorkflow(ctx context.Context, request *UpdateWorkflowReq, params UpdateWorkflowParams) (res UpdateWorkflowRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateWorkflowRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, UpdateWorkflowOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateWorkflowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateWorkflowRevisionAlias invokes updateWorkflowRevisionAlias operation.
//
// ワークフローのリビジョンエイリアスを更新する.
//
// PUT /workflows/{id}/revisions/{revisionId}/revision_alias
func (c *Client) UpdateWorkflowRevisionAlias(ctx context.Context, request *UpdateWorkflowRevisionAliasReq, params UpdateWorkflowRevisionAliasParams) (UpdateWorkflowRevisionAliasRes, error) {
	res, err := c.sendUpdateWorkflowRevisionAlias(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateWorkflowRevisionAlias(ctx context.Context, request *UpdateWorkflowRevisionAliasReq, params UpdateWorkflowRevisionAliasParams) (res UpdateWorkflowRevisionAliasRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/workflows/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/revisions/"
	{
		// Encode "revisionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "revisionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.RevisionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/revision_alias"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateWorkflowRevisionAliasRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityApiKeyAuth(ctx, UpdateWorkflowRevisionAliasOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"ApiKeyAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateWorkflowRevisionAliasResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
