// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestCancelExecutionAccepted_EncodeDecode(t *testing.T) {
	var typ CancelExecutionAccepted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionAccepted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCancelExecutionAccepted_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Execution\":{\"Args\":\"sampleString\",\"CancelRequestedAt\":\"2020-01-01T00:00:00Z\",\"CanceledAt\":\"2020-01-01T00:00:00Z\",\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Error\":\"sampleString\",\"ExecutionId\":\"sampleString\",\"FailedAt\":\"2020-01-01T00:00:00Z\",\"Name\":\"sampleString\",\"Result\":\"sampleString\",\"Revision\":123,\"RevisionAlias\":\"sampleString\",\"RunAt\":\"2020-01-01T00:00:00Z\",\"Status\":\"Queued\",\"SucceededAt\":\"2020-01-01T00:00:00Z\",\"UpdatedAt\":\"2020-01-01T00:00:00Z\",\"Workflow\":{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Description\":\"sampleString\",\"Id\":\"sampleString\",\"Logging\":true,\"Name\":\"sampleString\",\"Publish\":true,\"Tags\":[{\"Name\":\"sampleString\"}],\"UpdatedAt\":\"2020-01-01T00:00:00Z\"}},\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CancelExecutionAccepted

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CancelExecutionAccepted
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCancelExecutionAcceptedExecution_EncodeDecode(t *testing.T) {
	var typ CancelExecutionAcceptedExecution
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionAcceptedExecution
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCancelExecutionAcceptedExecutionStatus_EncodeDecode(t *testing.T) {
	var typ CancelExecutionAcceptedExecutionStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionAcceptedExecutionStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCancelExecutionAcceptedExecutionWorkflow_EncodeDecode(t *testing.T) {
	var typ CancelExecutionAcceptedExecutionWorkflow
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionAcceptedExecutionWorkflow
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCancelExecutionAcceptedExecutionWorkflowServicePrincipalId_EncodeDecode(t *testing.T) {
	var typ CancelExecutionAcceptedExecutionWorkflowServicePrincipalId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionAcceptedExecutionWorkflowServicePrincipalId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCancelExecutionAcceptedExecutionWorkflowTagsItem_EncodeDecode(t *testing.T) {
	var typ CancelExecutionAcceptedExecutionWorkflowTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionAcceptedExecutionWorkflowTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCancelExecutionBadRequest_EncodeDecode(t *testing.T) {
	var typ CancelExecutionBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCancelExecutionBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CancelExecutionBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CancelExecutionBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCancelExecutionConflict_EncodeDecode(t *testing.T) {
	var typ CancelExecutionConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCancelExecutionConflict_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Message\":\"sampleString\",\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CancelExecutionConflict

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CancelExecutionConflict
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCancelExecutionForbidden_EncodeDecode(t *testing.T) {
	var typ CancelExecutionForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCancelExecutionForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CancelExecutionForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CancelExecutionForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCancelExecutionInternalServerError_EncodeDecode(t *testing.T) {
	var typ CancelExecutionInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCancelExecutionInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CancelExecutionInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CancelExecutionInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCancelExecutionNotFound_EncodeDecode(t *testing.T) {
	var typ CancelExecutionNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCancelExecutionNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CancelExecutionNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CancelExecutionNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCancelExecutionOK_EncodeDecode(t *testing.T) {
	var typ CancelExecutionOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCancelExecutionOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Execution\":{\"Args\":\"sampleString\",\"CancelRequestedAt\":\"2020-01-01T00:00:00Z\",\"CanceledAt\":\"2020-01-01T00:00:00Z\",\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Error\":\"sampleString\",\"ExecutionId\":\"sampleString\",\"FailedAt\":\"2020-01-01T00:00:00Z\",\"Name\":\"sampleString\",\"Result\":\"sampleString\",\"Revision\":123,\"RevisionAlias\":\"sampleString\",\"RunAt\":\"2020-01-01T00:00:00Z\",\"Status\":\"Queued\",\"SucceededAt\":\"2020-01-01T00:00:00Z\",\"UpdatedAt\":\"2020-01-01T00:00:00Z\",\"Workflow\":{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Description\":\"sampleString\",\"Id\":\"sampleString\",\"Logging\":true,\"Name\":\"sampleString\",\"Publish\":true,\"Tags\":[{\"Name\":\"sampleString\"}],\"UpdatedAt\":\"2020-01-01T00:00:00Z\"}},\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CancelExecutionOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CancelExecutionOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCancelExecutionOKExecution_EncodeDecode(t *testing.T) {
	var typ CancelExecutionOKExecution
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionOKExecution
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCancelExecutionOKExecutionStatus_EncodeDecode(t *testing.T) {
	var typ CancelExecutionOKExecutionStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionOKExecutionStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCancelExecutionOKExecutionWorkflow_EncodeDecode(t *testing.T) {
	var typ CancelExecutionOKExecutionWorkflow
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionOKExecutionWorkflow
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCancelExecutionOKExecutionWorkflowServicePrincipalId_EncodeDecode(t *testing.T) {
	var typ CancelExecutionOKExecutionWorkflowServicePrincipalId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionOKExecutionWorkflowServicePrincipalId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCancelExecutionOKExecutionWorkflowTagsItem_EncodeDecode(t *testing.T) {
	var typ CancelExecutionOKExecutionWorkflowTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionOKExecutionWorkflowTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCancelExecutionUnauthorized_EncodeDecode(t *testing.T) {
	var typ CancelExecutionUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancelExecutionUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCancelExecutionUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CancelExecutionUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CancelExecutionUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateExecutionBadRequest_EncodeDecode(t *testing.T) {
	var typ CreateExecutionBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExecutionBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateExecutionBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateExecutionBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateExecutionBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateExecutionConflict_EncodeDecode(t *testing.T) {
	var typ CreateExecutionConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExecutionConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateExecutionConflict_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Message\":\"sampleString\",\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateExecutionConflict

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateExecutionConflict
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateExecutionCreated_EncodeDecode(t *testing.T) {
	var typ CreateExecutionCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExecutionCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateExecutionCreated_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Execution\":{\"Args\":\"sampleString\",\"CancelRequestedAt\":\"2020-01-01T00:00:00Z\",\"CanceledAt\":\"2020-01-01T00:00:00Z\",\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Error\":\"sampleString\",\"ExecutionId\":\"sampleString\",\"FailedAt\":\"2020-01-01T00:00:00Z\",\"Name\":\"sampleString\",\"Result\":\"sampleString\",\"Revision\":123,\"RevisionAlias\":\"sampleString\",\"RunAt\":\"2020-01-01T00:00:00Z\",\"Status\":\"Queued\",\"SucceededAt\":\"2020-01-01T00:00:00Z\",\"UpdatedAt\":\"2020-01-01T00:00:00Z\",\"Workflow\":{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Description\":\"sampleString\",\"Id\":\"sampleString\",\"Logging\":true,\"Name\":\"sampleString\",\"Publish\":true,\"Tags\":[{\"Name\":\"sampleString\"}],\"UpdatedAt\":\"2020-01-01T00:00:00Z\"}},\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateExecutionCreated

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateExecutionCreated
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateExecutionCreatedExecution_EncodeDecode(t *testing.T) {
	var typ CreateExecutionCreatedExecution
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExecutionCreatedExecution
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateExecutionCreatedExecutionStatus_EncodeDecode(t *testing.T) {
	var typ CreateExecutionCreatedExecutionStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExecutionCreatedExecutionStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateExecutionCreatedExecutionWorkflow_EncodeDecode(t *testing.T) {
	var typ CreateExecutionCreatedExecutionWorkflow
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExecutionCreatedExecutionWorkflow
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateExecutionCreatedExecutionWorkflowServicePrincipalId_EncodeDecode(t *testing.T) {
	var typ CreateExecutionCreatedExecutionWorkflowServicePrincipalId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExecutionCreatedExecutionWorkflowServicePrincipalId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateExecutionCreatedExecutionWorkflowTagsItem_EncodeDecode(t *testing.T) {
	var typ CreateExecutionCreatedExecutionWorkflowTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExecutionCreatedExecutionWorkflowTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateExecutionForbidden_EncodeDecode(t *testing.T) {
	var typ CreateExecutionForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExecutionForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateExecutionForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateExecutionForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateExecutionForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateExecutionInternalServerError_EncodeDecode(t *testing.T) {
	var typ CreateExecutionInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExecutionInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateExecutionInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateExecutionInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateExecutionInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateExecutionNotFound_EncodeDecode(t *testing.T) {
	var typ CreateExecutionNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExecutionNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateExecutionNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateExecutionNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateExecutionNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateExecutionReq_EncodeDecode(t *testing.T) {
	var typ CreateExecutionReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExecutionReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateExecutionReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Args\":\"sampleString\",\"Name\":\"sampleString\",\"RevisionAlias\":\"sampleString\",\"RevisionId\":123}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateExecutionReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateExecutionReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateExecutionUnauthorized_EncodeDecode(t *testing.T) {
	var typ CreateExecutionUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExecutionUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateExecutionUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateExecutionUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateExecutionUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateSubscriptionBadRequest_EncodeDecode(t *testing.T) {
	var typ CreateSubscriptionBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateSubscriptionBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateSubscriptionBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateSubscriptionBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateSubscriptionBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateSubscriptionForbidden_EncodeDecode(t *testing.T) {
	var typ CreateSubscriptionForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateSubscriptionForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateSubscriptionForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateSubscriptionForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateSubscriptionForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateSubscriptionInternalServerError_EncodeDecode(t *testing.T) {
	var typ CreateSubscriptionInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateSubscriptionInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateSubscriptionInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateSubscriptionInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateSubscriptionInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateSubscriptionNotFound_EncodeDecode(t *testing.T) {
	var typ CreateSubscriptionNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateSubscriptionNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateSubscriptionNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateSubscriptionNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateSubscriptionNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateSubscriptionReq_EncodeDecode(t *testing.T) {
	var typ CreateSubscriptionReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateSubscriptionReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateSubscriptionReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"PlanId\":123}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateSubscriptionReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateSubscriptionReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateSubscriptionUnauthorized_EncodeDecode(t *testing.T) {
	var typ CreateSubscriptionUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateSubscriptionUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateSubscriptionUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateSubscriptionUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateSubscriptionUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowBadRequest_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowCreated_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowCreated_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Workflow\":{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Description\":\"sampleString\",\"Id\":\"sampleString\",\"Logging\":true,\"Name\":\"sampleString\",\"Publish\":true,\"Tags\":[{\"Name\":\"sampleString\"}],\"UpdatedAt\":\"2020-01-01T00:00:00Z\"},\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowCreated

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowCreated
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowCreatedWorkflow_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowCreatedWorkflow
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowCreatedWorkflow
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateWorkflowCreatedWorkflowServicePrincipalId_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowCreatedWorkflowServicePrincipalId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowCreatedWorkflowServicePrincipalId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateWorkflowCreatedWorkflowTagsItem_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowCreatedWorkflowTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowCreatedWorkflowTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateWorkflowForbidden_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowInternalServerError_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowNotFound_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowReq_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Description\":\"sampleString\",\"Logging\":true,\"Name\":\"sampleString\",\"Publish\":true,\"RevisionAlias\":\"sampleString\",\"Runbook\":\"sampleString\",\"Tags\":[{\"Name\":\"sampleString\"}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowReqServicePrincipalId_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowReqServicePrincipalId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowReqServicePrincipalId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateWorkflowReqTagsItem_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowReqTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowReqTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateWorkflowRevisionBadRequest_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowRevisionBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowRevisionBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowRevisionBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowRevisionBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowRevisionBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowRevisionConflict_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowRevisionConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowRevisionConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowRevisionConflict_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Message\":\"sampleString\",\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowRevisionConflict

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowRevisionConflict
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowRevisionCreated_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowRevisionCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowRevisionCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowRevisionCreated_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Revision\":{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"RevisionAlias\":\"sampleString\",\"RevisionId\":123,\"Runbook\":\"sampleString\",\"UpdatedAt\":\"2020-01-01T00:00:00Z\",\"WorkflowId\":\"sampleString\"},\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowRevisionCreated

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowRevisionCreated
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowRevisionCreatedRevision_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowRevisionCreatedRevision
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowRevisionCreatedRevision
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateWorkflowRevisionForbidden_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowRevisionForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowRevisionForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowRevisionForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowRevisionForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowRevisionForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowRevisionInternalServerError_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowRevisionInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowRevisionInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowRevisionInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowRevisionInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowRevisionInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowRevisionNotFound_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowRevisionNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowRevisionNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowRevisionNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowRevisionNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowRevisionNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowRevisionReq_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowRevisionReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowRevisionReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowRevisionReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"RevisionAlias\":\"sampleString\",\"Runbook\":\"sampleString\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowRevisionReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowRevisionReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowRevisionUnauthorized_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowRevisionUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowRevisionUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowRevisionUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowRevisionUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowRevisionUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateWorkflowUnauthorized_EncodeDecode(t *testing.T) {
	var typ CreateWorkflowUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWorkflowUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateWorkflowUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateWorkflowUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateWorkflowUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteExecutionBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteExecutionBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteExecutionBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteExecutionBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteExecutionBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteExecutionBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteExecutionConflict_EncodeDecode(t *testing.T) {
	var typ DeleteExecutionConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteExecutionConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteExecutionConflict_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Message\":\"sampleString\",\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteExecutionConflict

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteExecutionConflict
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteExecutionForbidden_EncodeDecode(t *testing.T) {
	var typ DeleteExecutionForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteExecutionForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteExecutionForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteExecutionForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteExecutionForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteExecutionInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteExecutionInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteExecutionInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteExecutionInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteExecutionInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteExecutionInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteExecutionNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteExecutionNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteExecutionNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteExecutionNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteExecutionNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteExecutionNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteExecutionOK_EncodeDecode(t *testing.T) {
	var typ DeleteExecutionOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteExecutionOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteExecutionOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteExecutionOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteExecutionOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteExecutionUnauthorized_EncodeDecode(t *testing.T) {
	var typ DeleteExecutionUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteExecutionUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteExecutionUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteExecutionUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteExecutionUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteSubscriptionBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteSubscriptionBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteSubscriptionBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteSubscriptionBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteSubscriptionBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteSubscriptionBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteSubscriptionForbidden_EncodeDecode(t *testing.T) {
	var typ DeleteSubscriptionForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteSubscriptionForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteSubscriptionForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteSubscriptionForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteSubscriptionForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteSubscriptionInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteSubscriptionInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteSubscriptionInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteSubscriptionInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteSubscriptionInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteSubscriptionInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteSubscriptionNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteSubscriptionNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteSubscriptionNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteSubscriptionNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteSubscriptionNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteSubscriptionNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteSubscriptionUnauthorized_EncodeDecode(t *testing.T) {
	var typ DeleteSubscriptionUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteSubscriptionUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteSubscriptionUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteSubscriptionUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteSubscriptionUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteWorkflowBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteWorkflowBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteWorkflowBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteWorkflowBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteWorkflowConflict_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteWorkflowConflict_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Message\":\"sampleString\",\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteWorkflowConflict

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteWorkflowConflict
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteWorkflowForbidden_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteWorkflowForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteWorkflowForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteWorkflowForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteWorkflowInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteWorkflowInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteWorkflowInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteWorkflowInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteWorkflowNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteWorkflowNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteWorkflowNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteWorkflowNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteWorkflowOK_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteWorkflowOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteWorkflowOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteWorkflowOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteWorkflowRevisionAliasBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowRevisionAliasBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowRevisionAliasBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteWorkflowRevisionAliasBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteWorkflowRevisionAliasBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteWorkflowRevisionAliasBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteWorkflowRevisionAliasForbidden_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowRevisionAliasForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowRevisionAliasForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteWorkflowRevisionAliasForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteWorkflowRevisionAliasForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteWorkflowRevisionAliasForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteWorkflowRevisionAliasInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowRevisionAliasInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowRevisionAliasInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteWorkflowRevisionAliasInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteWorkflowRevisionAliasInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteWorkflowRevisionAliasInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteWorkflowRevisionAliasNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowRevisionAliasNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowRevisionAliasNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteWorkflowRevisionAliasNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteWorkflowRevisionAliasNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteWorkflowRevisionAliasNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteWorkflowRevisionAliasOK_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowRevisionAliasOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowRevisionAliasOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteWorkflowRevisionAliasOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Revision\":{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"RevisionAlias\":\"sampleString\",\"RevisionId\":123,\"Runbook\":\"sampleString\",\"UpdatedAt\":\"2020-01-01T00:00:00Z\",\"WorkflowId\":\"sampleString\"},\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteWorkflowRevisionAliasOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteWorkflowRevisionAliasOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteWorkflowRevisionAliasOKRevision_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowRevisionAliasOKRevision
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowRevisionAliasOKRevision
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteWorkflowRevisionAliasUnauthorized_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowRevisionAliasUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowRevisionAliasUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteWorkflowRevisionAliasUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteWorkflowRevisionAliasUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteWorkflowRevisionAliasUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeleteWorkflowUnauthorized_EncodeDecode(t *testing.T) {
	var typ DeleteWorkflowUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteWorkflowUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeleteWorkflowUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeleteWorkflowUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeleteWorkflowUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetExecutionBadRequest_EncodeDecode(t *testing.T) {
	var typ GetExecutionBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExecutionBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetExecutionBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetExecutionBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetExecutionBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetExecutionForbidden_EncodeDecode(t *testing.T) {
	var typ GetExecutionForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExecutionForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetExecutionForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetExecutionForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetExecutionForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetExecutionInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetExecutionInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExecutionInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetExecutionInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetExecutionInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetExecutionInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetExecutionNotFound_EncodeDecode(t *testing.T) {
	var typ GetExecutionNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExecutionNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetExecutionNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetExecutionNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetExecutionNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetExecutionOK_EncodeDecode(t *testing.T) {
	var typ GetExecutionOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExecutionOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetExecutionOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Execution\":{\"Args\":\"sampleString\",\"CancelRequestedAt\":\"2020-01-01T00:00:00Z\",\"CanceledAt\":\"2020-01-01T00:00:00Z\",\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Error\":\"sampleString\",\"ExecutionId\":\"sampleString\",\"FailedAt\":\"2020-01-01T00:00:00Z\",\"Name\":\"sampleString\",\"Result\":\"sampleString\",\"Revision\":123,\"RevisionAlias\":\"sampleString\",\"RunAt\":\"2020-01-01T00:00:00Z\",\"Status\":\"Queued\",\"SucceededAt\":\"2020-01-01T00:00:00Z\",\"UpdatedAt\":\"2020-01-01T00:00:00Z\",\"Workflow\":{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Description\":\"sampleString\",\"Id\":\"sampleString\",\"Logging\":true,\"Name\":\"sampleString\",\"Publish\":true,\"Tags\":[{\"Name\":\"sampleString\"}],\"UpdatedAt\":\"2020-01-01T00:00:00Z\"}},\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetExecutionOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetExecutionOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetExecutionOKExecution_EncodeDecode(t *testing.T) {
	var typ GetExecutionOKExecution
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExecutionOKExecution
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExecutionOKExecutionStatus_EncodeDecode(t *testing.T) {
	var typ GetExecutionOKExecutionStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExecutionOKExecutionStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExecutionOKExecutionWorkflow_EncodeDecode(t *testing.T) {
	var typ GetExecutionOKExecutionWorkflow
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExecutionOKExecutionWorkflow
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExecutionOKExecutionWorkflowServicePrincipalId_EncodeDecode(t *testing.T) {
	var typ GetExecutionOKExecutionWorkflowServicePrincipalId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExecutionOKExecutionWorkflowServicePrincipalId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExecutionOKExecutionWorkflowTagsItem_EncodeDecode(t *testing.T) {
	var typ GetExecutionOKExecutionWorkflowTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExecutionOKExecutionWorkflowTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExecutionUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetExecutionUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExecutionUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetExecutionUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetExecutionUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetExecutionUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetSubscriptionBadRequest_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetSubscriptionBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetSubscriptionBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetSubscriptionBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetSubscriptionForbidden_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetSubscriptionForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetSubscriptionForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetSubscriptionForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetSubscriptionInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetSubscriptionInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetSubscriptionInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetSubscriptionInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetSubscriptionNotFound_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetSubscriptionNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetSubscriptionNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetSubscriptionNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetSubscriptionOK_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetSubscriptionOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"CurrentPlan\":{\"accountId\":\"sampleString\",\"activateFrom\":\"2020-01-01T00:00:00Z\",\"contractId\":\"sampleString\",\"createdAt\":\"2020-01-01T00:00:00Z\",\"id\":\"sampleString\",\"planId\":123,\"planName\":\"sampleString\",\"updatedAt\":\"2020-01-01T00:00:00Z\"},\"MonthAppliedPlan\":{\"accountId\":\"sampleString\",\"activateFrom\":\"2020-01-01T00:00:00Z\",\"contractId\":\"sampleString\",\"createdAt\":\"2020-01-01T00:00:00Z\",\"id\":\"sampleString\",\"planGrade\":123,\"planId\":123,\"planName\":\"sampleString\",\"updatedAt\":\"2020-01-01T00:00:00Z\"},\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetSubscriptionOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetSubscriptionOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetSubscriptionOKCurrentPlan_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionOKCurrentPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionOKCurrentPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionOKMonthAppliedPlan_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionOKMonthAppliedPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionOKMonthAppliedPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetSubscriptionUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetSubscriptionUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetSubscriptionUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetWorkflowBadRequest_EncodeDecode(t *testing.T) {
	var typ GetWorkflowBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetWorkflowBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetWorkflowBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetWorkflowBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetWorkflowForbidden_EncodeDecode(t *testing.T) {
	var typ GetWorkflowForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetWorkflowForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetWorkflowForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetWorkflowForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetWorkflowInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetWorkflowInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetWorkflowInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetWorkflowInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetWorkflowInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetWorkflowNotFound_EncodeDecode(t *testing.T) {
	var typ GetWorkflowNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetWorkflowNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetWorkflowNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetWorkflowNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetWorkflowOK_EncodeDecode(t *testing.T) {
	var typ GetWorkflowOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetWorkflowOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Workflow\":{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Description\":\"sampleString\",\"Id\":\"sampleString\",\"Logging\":true,\"Name\":\"sampleString\",\"Publish\":true,\"Tags\":[{\"Name\":\"sampleString\"}],\"UpdatedAt\":\"2020-01-01T00:00:00Z\"},\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetWorkflowOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetWorkflowOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetWorkflowOKWorkflow_EncodeDecode(t *testing.T) {
	var typ GetWorkflowOKWorkflow
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowOKWorkflow
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowOKWorkflowServicePrincipalId_EncodeDecode(t *testing.T) {
	var typ GetWorkflowOKWorkflowServicePrincipalId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowOKWorkflowServicePrincipalId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowOKWorkflowTagsItem_EncodeDecode(t *testing.T) {
	var typ GetWorkflowOKWorkflowTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowOKWorkflowTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowRevisionsBadRequest_EncodeDecode(t *testing.T) {
	var typ GetWorkflowRevisionsBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowRevisionsBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetWorkflowRevisionsBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetWorkflowRevisionsBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetWorkflowRevisionsBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetWorkflowRevisionsForbidden_EncodeDecode(t *testing.T) {
	var typ GetWorkflowRevisionsForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowRevisionsForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetWorkflowRevisionsForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetWorkflowRevisionsForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetWorkflowRevisionsForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetWorkflowRevisionsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetWorkflowRevisionsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowRevisionsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetWorkflowRevisionsInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetWorkflowRevisionsInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetWorkflowRevisionsInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetWorkflowRevisionsNotFound_EncodeDecode(t *testing.T) {
	var typ GetWorkflowRevisionsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowRevisionsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetWorkflowRevisionsNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetWorkflowRevisionsNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetWorkflowRevisionsNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetWorkflowRevisionsOK_EncodeDecode(t *testing.T) {
	var typ GetWorkflowRevisionsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowRevisionsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetWorkflowRevisionsOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Revision\":{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"RevisionAlias\":\"sampleString\",\"RevisionId\":123,\"Runbook\":\"sampleString\",\"UpdatedAt\":\"2020-01-01T00:00:00Z\",\"WorkflowId\":\"sampleString\"},\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetWorkflowRevisionsOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetWorkflowRevisionsOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetWorkflowRevisionsOKRevision_EncodeDecode(t *testing.T) {
	var typ GetWorkflowRevisionsOKRevision
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowRevisionsOKRevision
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetWorkflowRevisionsUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetWorkflowRevisionsUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowRevisionsUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetWorkflowRevisionsUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetWorkflowRevisionsUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetWorkflowRevisionsUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetWorkflowUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetWorkflowUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetWorkflowUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetWorkflowUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetWorkflowUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetWorkflowUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListExecutionBadRequest_EncodeDecode(t *testing.T) {
	var typ ListExecutionBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListExecutionBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListExecutionBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListExecutionBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListExecutionForbidden_EncodeDecode(t *testing.T) {
	var typ ListExecutionForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListExecutionForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListExecutionForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListExecutionForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListExecutionHistoryBadRequest_EncodeDecode(t *testing.T) {
	var typ ListExecutionHistoryBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionHistoryBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListExecutionHistoryBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListExecutionHistoryBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListExecutionHistoryBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListExecutionHistoryForbidden_EncodeDecode(t *testing.T) {
	var typ ListExecutionHistoryForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionHistoryForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListExecutionHistoryForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListExecutionHistoryForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListExecutionHistoryForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListExecutionHistoryInternalServerError_EncodeDecode(t *testing.T) {
	var typ ListExecutionHistoryInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionHistoryInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListExecutionHistoryInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListExecutionHistoryInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListExecutionHistoryInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListExecutionHistoryNotFound_EncodeDecode(t *testing.T) {
	var typ ListExecutionHistoryNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionHistoryNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListExecutionHistoryNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListExecutionHistoryNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListExecutionHistoryNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListExecutionHistoryOK_EncodeDecode(t *testing.T) {
	var typ ListExecutionHistoryOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionHistoryOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListExecutionHistoryOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Count\":123,\"From\":123,\"Histories\":[{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"JobId\":\"sampleString\",\"Meta\":\"sampleString\",\"StackTrace\":\"sampleString\",\"ThreadId\":\"sampleString\",\"Type\":\"workflowWillStart\",\"Variables\":\"sampleString\",\"WorkflowExecutionId\":\"sampleString\"}],\"Total\":123,\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListExecutionHistoryOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListExecutionHistoryOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListExecutionHistoryOKHistoriesItem_EncodeDecode(t *testing.T) {
	var typ ListExecutionHistoryOKHistoriesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionHistoryOKHistoriesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListExecutionHistoryOKHistoriesItemType_EncodeDecode(t *testing.T) {
	var typ ListExecutionHistoryOKHistoriesItemType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionHistoryOKHistoriesItemType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListExecutionHistoryUnauthorized_EncodeDecode(t *testing.T) {
	var typ ListExecutionHistoryUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionHistoryUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListExecutionHistoryUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListExecutionHistoryUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListExecutionHistoryUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListExecutionInternalServerError_EncodeDecode(t *testing.T) {
	var typ ListExecutionInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListExecutionInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListExecutionInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListExecutionInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListExecutionNotFound_EncodeDecode(t *testing.T) {
	var typ ListExecutionNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListExecutionNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListExecutionNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListExecutionNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListExecutionOK_EncodeDecode(t *testing.T) {
	var typ ListExecutionOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListExecutionOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Count\":123,\"Executions\":[{\"Args\":\"sampleString\",\"CancelRequestedAt\":\"2020-01-01T00:00:00Z\",\"CanceledAt\":\"2020-01-01T00:00:00Z\",\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Error\":\"sampleString\",\"ExecutionId\":\"sampleString\",\"FailedAt\":\"2020-01-01T00:00:00Z\",\"Name\":\"sampleString\",\"Result\":\"sampleString\",\"Revision\":123,\"RevisionAlias\":\"sampleString\",\"RunAt\":\"2020-01-01T00:00:00Z\",\"Status\":\"Queued\",\"SucceededAt\":\"2020-01-01T00:00:00Z\",\"UpdatedAt\":\"2020-01-01T00:00:00Z\",\"Workflow\":{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Description\":\"sampleString\",\"Id\":\"sampleString\",\"Logging\":true,\"Name\":\"sampleString\",\"Publish\":true,\"Tags\":[{\"Name\":\"sampleString\"}],\"UpdatedAt\":\"2020-01-01T00:00:00Z\"}}],\"From\":123,\"Total\":123,\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListExecutionOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListExecutionOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListExecutionOKExecutionsItem_EncodeDecode(t *testing.T) {
	var typ ListExecutionOKExecutionsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionOKExecutionsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListExecutionOKExecutionsItemStatus_EncodeDecode(t *testing.T) {
	var typ ListExecutionOKExecutionsItemStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionOKExecutionsItemStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListExecutionOKExecutionsItemWorkflow_EncodeDecode(t *testing.T) {
	var typ ListExecutionOKExecutionsItemWorkflow
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionOKExecutionsItemWorkflow
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListExecutionOKExecutionsItemWorkflowServicePrincipalId_EncodeDecode(t *testing.T) {
	var typ ListExecutionOKExecutionsItemWorkflowServicePrincipalId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionOKExecutionsItemWorkflowServicePrincipalId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListExecutionOKExecutionsItemWorkflowTagsItem_EncodeDecode(t *testing.T) {
	var typ ListExecutionOKExecutionsItemWorkflowTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionOKExecutionsItemWorkflowTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListExecutionUnauthorized_EncodeDecode(t *testing.T) {
	var typ ListExecutionUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListExecutionUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListExecutionUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListExecutionUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListExecutionUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListPlansBadRequest_EncodeDecode(t *testing.T) {
	var typ ListPlansBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPlansBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListPlansBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListPlansBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListPlansBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListPlansForbidden_EncodeDecode(t *testing.T) {
	var typ ListPlansForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPlansForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListPlansForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListPlansForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListPlansForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListPlansInternalServerError_EncodeDecode(t *testing.T) {
	var typ ListPlansInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPlansInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListPlansInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListPlansInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListPlansInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListPlansNotFound_EncodeDecode(t *testing.T) {
	var typ ListPlansNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPlansNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListPlansNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListPlansNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListPlansNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListPlansOK_EncodeDecode(t *testing.T) {
	var typ ListPlansOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPlansOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListPlansOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Plans\":[{\"basePrice\":123,\"grade\":123,\"id\":123,\"includedSteps\":123,\"name\":\"sampleString\",\"overagePricePerUnit\":123,\"overageStepUnit\":123,\"serviceClassPath\":\"sampleString\"}],\"TaxRate\":10,\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListPlansOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListPlansOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListPlansOKPlansItem_EncodeDecode(t *testing.T) {
	var typ ListPlansOKPlansItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPlansOKPlansItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListPlansUnauthorized_EncodeDecode(t *testing.T) {
	var typ ListPlansUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPlansUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListPlansUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListPlansUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListPlansUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowBadRequest_EncodeDecode(t *testing.T) {
	var typ ListWorkflowBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowForbidden_EncodeDecode(t *testing.T) {
	var typ ListWorkflowForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowInternalServerError_EncodeDecode(t *testing.T) {
	var typ ListWorkflowInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowNotFound_EncodeDecode(t *testing.T) {
	var typ ListWorkflowNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowOK_EncodeDecode(t *testing.T) {
	var typ ListWorkflowOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Count\":123,\"From\":123,\"Total\":123,\"Workflows\":[{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Description\":\"sampleString\",\"Id\":\"sampleString\",\"Logging\":true,\"Name\":\"sampleString\",\"Publish\":true,\"Tags\":[{\"Name\":\"sampleString\"}],\"UpdatedAt\":\"2020-01-01T00:00:00Z\"}],\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowOKWorkflowsItem_EncodeDecode(t *testing.T) {
	var typ ListWorkflowOKWorkflowsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowOKWorkflowsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListWorkflowOKWorkflowsItemServicePrincipalId_EncodeDecode(t *testing.T) {
	var typ ListWorkflowOKWorkflowsItemServicePrincipalId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowOKWorkflowsItemServicePrincipalId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListWorkflowOKWorkflowsItemTagsItem_EncodeDecode(t *testing.T) {
	var typ ListWorkflowOKWorkflowsItemTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowOKWorkflowsItemTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListWorkflowRevisionsBadRequest_EncodeDecode(t *testing.T) {
	var typ ListWorkflowRevisionsBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowRevisionsBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowRevisionsBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowRevisionsBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowRevisionsBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowRevisionsForbidden_EncodeDecode(t *testing.T) {
	var typ ListWorkflowRevisionsForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowRevisionsForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowRevisionsForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowRevisionsForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowRevisionsForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowRevisionsInternalServerError_EncodeDecode(t *testing.T) {
	var typ ListWorkflowRevisionsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowRevisionsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowRevisionsInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowRevisionsInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowRevisionsInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowRevisionsNotFound_EncodeDecode(t *testing.T) {
	var typ ListWorkflowRevisionsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowRevisionsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowRevisionsNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowRevisionsNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowRevisionsNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowRevisionsOK_EncodeDecode(t *testing.T) {
	var typ ListWorkflowRevisionsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowRevisionsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowRevisionsOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Count\":123,\"From\":123,\"Revisions\":[{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"RevisionAlias\":\"sampleString\",\"RevisionId\":123,\"Runbook\":\"sampleString\",\"UpdatedAt\":\"2020-01-01T00:00:00Z\",\"WorkflowId\":\"sampleString\"}],\"Total\":123,\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowRevisionsOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowRevisionsOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowRevisionsOKRevisionsItem_EncodeDecode(t *testing.T) {
	var typ ListWorkflowRevisionsOKRevisionsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowRevisionsOKRevisionsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListWorkflowRevisionsUnauthorized_EncodeDecode(t *testing.T) {
	var typ ListWorkflowRevisionsUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowRevisionsUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowRevisionsUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowRevisionsUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowRevisionsUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowSuggestBadRequest_EncodeDecode(t *testing.T) {
	var typ ListWorkflowSuggestBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowSuggestBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowSuggestBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowSuggestBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowSuggestBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowSuggestForbidden_EncodeDecode(t *testing.T) {
	var typ ListWorkflowSuggestForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowSuggestForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowSuggestForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowSuggestForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowSuggestForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowSuggestInternalServerError_EncodeDecode(t *testing.T) {
	var typ ListWorkflowSuggestInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowSuggestInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowSuggestInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowSuggestInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowSuggestInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowSuggestNotFound_EncodeDecode(t *testing.T) {
	var typ ListWorkflowSuggestNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowSuggestNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowSuggestNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowSuggestNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowSuggestNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowSuggestOK_EncodeDecode(t *testing.T) {
	var typ ListWorkflowSuggestOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowSuggestOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowSuggestOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Count\":123,\"From\":123,\"Suggests\":[{\"Count\":123,\"Name\":\"sampleString\"}],\"Total\":123,\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowSuggestOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowSuggestOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowSuggestOKSuggestsItem_EncodeDecode(t *testing.T) {
	var typ ListWorkflowSuggestOKSuggestsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowSuggestOKSuggestsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListWorkflowSuggestUnauthorized_EncodeDecode(t *testing.T) {
	var typ ListWorkflowSuggestUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowSuggestUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowSuggestUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowSuggestUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowSuggestUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestListWorkflowUnauthorized_EncodeDecode(t *testing.T) {
	var typ ListWorkflowUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListWorkflowUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestListWorkflowUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ListWorkflowUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ListWorkflowUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowBadRequest_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowForbidden_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowNotFound_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowOK_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Workflow\":{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"Description\":\"sampleString\",\"Id\":\"sampleString\",\"Logging\":true,\"Name\":\"sampleString\",\"Publish\":true,\"Tags\":[{\"Name\":\"sampleString\"}],\"UpdatedAt\":\"2020-01-01T00:00:00Z\"},\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowOKWorkflow_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowOKWorkflow
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowOKWorkflow
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateWorkflowOKWorkflowServicePrincipalId_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowOKWorkflowServicePrincipalId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowOKWorkflowServicePrincipalId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateWorkflowOKWorkflowTagsItem_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowOKWorkflowTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowOKWorkflowTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateWorkflowReq_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Description\":\"sampleString\",\"Logging\":true,\"Name\":\"sampleString\",\"Publish\":true,\"Tags\":[{\"Name\":\"sampleString\"}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowReqTagsItem_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowReqTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowReqTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateWorkflowRevisionAliasBadRequest_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowRevisionAliasBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowRevisionAliasBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowRevisionAliasBadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Bad Request\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowRevisionAliasBadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowRevisionAliasBadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowRevisionAliasConflict_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowRevisionAliasConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowRevisionAliasConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowRevisionAliasConflict_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Message\":\"sampleString\",\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowRevisionAliasConflict

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowRevisionAliasConflict
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowRevisionAliasForbidden_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowRevisionAliasForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowRevisionAliasForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowRevisionAliasForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Forbidden\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowRevisionAliasForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowRevisionAliasForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowRevisionAliasInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowRevisionAliasInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowRevisionAliasInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowRevisionAliasInternalServerError_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Internal Server Error\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowRevisionAliasInternalServerError

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowRevisionAliasInternalServerError
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowRevisionAliasNotFound_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowRevisionAliasNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowRevisionAliasNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowRevisionAliasNotFound_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Not Found\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowRevisionAliasNotFound

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowRevisionAliasNotFound
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowRevisionAliasOK_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowRevisionAliasOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowRevisionAliasOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowRevisionAliasOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Revision\":{\"CreatedAt\":\"2020-01-01T00:00:00Z\",\"RevisionAlias\":\"sampleString\",\"RevisionId\":123,\"Runbook\":\"sampleString\",\"UpdatedAt\":\"2020-01-01T00:00:00Z\",\"WorkflowId\":\"sampleString\"},\"is_ok\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowRevisionAliasOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowRevisionAliasOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowRevisionAliasOKRevision_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowRevisionAliasOKRevision
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowRevisionAliasOKRevision
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateWorkflowRevisionAliasReq_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowRevisionAliasReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowRevisionAliasReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowRevisionAliasReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"RevisionAlias\":\"sampleString\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowRevisionAliasReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowRevisionAliasReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowRevisionAliasUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowRevisionAliasUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowRevisionAliasUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowRevisionAliasUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowRevisionAliasUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowRevisionAliasUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateWorkflowUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpdateWorkflowUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWorkflowUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUpdateWorkflowUnauthorized_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"is_ok\":false,\"message\":\"Unauthorized\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UpdateWorkflowUnauthorized

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UpdateWorkflowUnauthorized
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
